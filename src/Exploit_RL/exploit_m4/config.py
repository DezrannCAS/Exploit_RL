from dataclasses import dataclass
import torch

@dataclass
class Args:
    s0_case: dict = {"case": "constant", "value": 1.0}
    #s0_case: dict = {"case": "random", "value": np.nan}
    """initial stocks"""
    max_stock: float = 1.0
    """resources capacity"""
    growth_rate: float = 0.7
    """resources intrinsic growth"""
    dt: float = 1.0
    """time step"""
    num_agents: int = 3
    """number of agents in interaction"""
    num_minibatches: int = 5
    """number of minibatches in each iteration"""
    len_trajectories: int = 100
    """length of trajectories to collect for training"""
    learning_rate: float = 1e-4
    """learning rate for the optimizer"""
    gamma: float = 0.99
    """discount factor for future rewards"""
    gae_lambda: float = 0.95
    """Generalized Advantage Estimation (GAE) trace decay factor"""
    clip_coef: float = 0.2
    """clipping coefficient to limit policy updates"""
    c_val: float = 0.1
    """scaling coefficient for the value function loss"""
    c_aux: float = 3.0
    """scaling coefficient for the auxiliary function loss."""
    c_ent: float = 1e-5
    """scaling coefficient for the entropy loss (encourages exploration)"""
    num_iterations: int = 500
    """total number of training iterations"""
    num_episodes: int = 20 #120
    """number of episodes to run per iteration"""
    num_steps: int = 1000
    """number of steps per episode"""
    num_epochs: int = 30
    """number of epochs to process minibatches"""
    device: torch.device = None
    """device to be used for computation (CUDA, XPU or CPU), automatically determined"""
    
    def __post_init__(self):
        self.device = Args.get_device()
        print(f"Using device: {self.device}")
    
    @staticmethod
    def get_device():
        if torch.cuda.is_available():
            return torch.device("cuda")
        elif hasattr(torch, 'xpu') and torch.xpu.is_available():
            return torch.device("xpu")
        else:
            return torch.device("cpu")