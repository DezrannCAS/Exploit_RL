from functools import partial
from multiprocessing import Pool
from tqdm import tqdm
import numpy as np
import networkx as nx

def simulate(seed, free_params, fixed_params, TrainerClass):
    np.random.seed(seed)

    # Simulate using a Erdős–Rényi graph with given link density
    adjacency_matrix = nx.adjacency_matrix(nx.erdos_renyi_graph(fixed_params.num_agents, fixed_params.link_density)).toarray()
    assert len(np.where(adjacency_matrix.sum(axis=1) == 0)[0]) == 0, 'The adjacency matrix contains isolated agents'

    trainer = TrainerClass(adjacency_matrix, fixed_params, free_params)

    if hasattr(fixed_params, 'num_episodes'):
        # Train
        for _ in range(fixed_params.num_episodes):
            trainer.reset_episode()
            _ = trainer.run()

        # Test
        return trainer.run(update_q=False)
    else:
        return trainer.run()

def parallel_simulations(seed, free_params, fixed_params, TrainerClass):
    simulate_partial = partial(simulate, seed, free_params=free_params, fixed_params=fixed_params, TrainerClass=TrainerClass)

    print('Starting multiprocessing')
    with Pool(processes=fixed_params.num_jobs) as pool:
        results = list(tqdm(pool.imap(simulate_partial, range(fixed_params.num_simulations)), 
                            total=fixed_params.num_simulations))
    print('Done multiprocessing')

    return free_params, np.mean(results, axis=0) # average across simulations
